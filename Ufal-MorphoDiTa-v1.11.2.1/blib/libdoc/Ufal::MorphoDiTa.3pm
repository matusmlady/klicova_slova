.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ufal::MorphoDiTa 3pm"
.TH Ufal::MorphoDiTa 3pm "2024-06-16" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Ufal::MorphoDiTa \- bindings to MorphoDiTa library <http://ufal.mff.cuni.cz/morphodita>.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Ufal::MorphoDiTa;
\&
\&  my $tagger_file = \*(Aqenglish\-morphium\-wsj\-140407.tagger\*(Aq;
\&  my $tagger = Ufal::MorphoDiTa::Tagger::load($tagger_file) or die "Cannot load tagger from file \*(Aq$tagger_file\*(Aq\en";
\&  my $forms  = Ufal::MorphoDiTa::Forms\->new(); $forms\->push($_) for qw(How are you ?);
\&  my $lemmas = Ufal::MorphoDiTa::TaggedLemmas\->new();
\&
\&  $tagger\->tag($forms, $lemmas);
\&
\&  for my $i (0 .. $lemmas\->size()\-1) {
\&    my $lemma = $lemmas\->get($i);
\&    printf "token = %s, lemma = %s, tag = %s\en", $forms\->get($i), $lemma\->{lemma}, $lemma\->{tag};
\&  }
.Ve
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
To compile the module, \*(C+11 compiler is needed, either \f(CW\*(C`g++\*(C'\fR 4.7 or newer,
\&\f(CW\*(C`clang\*(C'\fR 3.2 or newer or \f(CW\*(C`Visual Studio 2015\*(C'\fR.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Ufal::MorphoDiTa\*(C'\fR is a Perl binding to MorphoDiTa library <http://ufal.mff.cuni.cz/morphodita>.
.PP
The bindings is a straightforward conversion of the \*(C+ bindings \s-1API.\s0
Vectors do not have native Perl interface, see Ufal::MorphoDiTa::Forms
source for reference. Static methods and enumerations are available only
through the module, not through object instance.
.SS "Wrapped \*(C+ \s-1API\s0"
.IX Subsection "Wrapped API"
The \*(C+ \s-1API\s0 being wrapped follows. For a \s-1API\s0 reference of the original
\&\*(C+ \s-1API,\s0 see L\e<http://ufal.mff.cuni.cz/morphodita/api\-reference\e>.
.PP
.Vb 2
\&  Helper Structures
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  
\&    typedef vector<int> Indices;
\&  
\&    typedef vector<string> Forms;
\&  
\&    struct TaggedForm {
\&      string form;
\&      string tag;
\&    };
\&    typedef vector<TaggedForm> TaggedForms;
\&  
\&    struct TaggedLemma {
\&      string lemma;
\&      string tag;
\&    };
\&    typedef vector<TaggedLemma> TaggedLemmas;
\&    typedef vector<TaggedLemmas> Analyses;
\&  
\&    struct TaggedLemmaForms {
\&      string lemma;
\&      TaggedForms forms;
\&    };
\&    typedef vector<TaggedLemmaForms> TaggedLemmasForms;
\&  
\&    struct TokenRange {
\&      size_t start;
\&      size_t length;
\&    };
\&    typedef vector<TokenRange> TokenRanges;
\&  
\&    struct DerivatedLemma {
\&      std::string lemma;
\&    };
\&    typedef vector<DerivatedLemma> DerivatedLemmas;
\&  
\&  
\&  Main Classes
\&  \-\-\-\-\-\-\-\-\-\-\-\-
\&  
\&    class Version {
\&     public:
\&      unsigned major;
\&      unsigned minor;
\&      unsigned patch;
\&      string prerelease;
\&  
\&      static Version current();
\&    };
\&  
\&    class Tokenizer {
\&     public:
\&      virtual void setText(const char* text);
\&      virtual bool nextSentence(Forms* forms, TokenRanges* tokens);
\&  
\&      static Tokenizer* newVerticalTokenizer();
\&      static Tokenizer* newCzechTokenizer();
\&      static Tokenizer* newEnglishTokenizer();
\&      static Tokenizer* newGenericTokenizer();
\&    };
\&  
\&    class TagsetConverter {
\&     public:
\&      static TagsetConverter* newIdentityConverter();
\&      static TagsetConverter* newPdtToConll2009Converter();
\&      static TagsetConverter* newStripLemmaCommentConverter(const Morpho& morpho);
\&      static TagsetConverter* newStripLemmaIdConverter(const Morpho& morpho);
\&  
\&      virtual void convert(TaggedLemma& lemma) const;
\&      virtual void convertAnalyzed(TaggedLemmas& lemmas) const;
\&      virtual void convertGenerated(TaggedLemmasForms& forms) const;
\&    };
\&  
\&    class Derivator {
\&     public:
\&      virtual bool parent(const char* lemma, DerivatedLemma& parent) const;
\&      virtual bool children(const char* lemma, DerivatedLemmas& children) const;
\&    };
\&  
\&    class DerivationFormatter {
\&     public:
\&      virtual string formatDerivation(const char* lemma) const;
\&      virtual void formatTaggedLemma(TaggedLemma& tagged_lemma, const TagsetConverter* converter = nullptr) const;
\&      virtual void formatTaggedLemmas(TaggedLemmas& tagged_lemma, const TagsetConverter* converter = nullptr) const;
\&  
\&      static DerivationFormatter* newNoneDerivationFormatter();
\&      static DerivationFormatter* newRootDerivationFormatter(const Derivator* derivator);
\&      static DerivationFormatter* newPathDerivationFormatter(const Derivator* derivator);
\&      static DerivationFormatter* newTreeDerivationFormatter(const Derivator* derivator);
\&      static DerivationFormatter* newDerivationFormatter(const char* name, const Derivator* derivator);
\&    };
\&  
\&    class Morpho {
\&     public:
\&      static Morpho* load(const char* fname);
\&  
\&      enum { NO_GUESSER = 0, GUESSER = 1, GUESSER_UNSPECIFIED = \-1 };
\&  
\&      virtual int analyze(const char* form, int guesser, TaggedLemmas& lemmas) const;
\&      virtual int generate(const char* lemma, const char* tag_wildcard, int guesser, TaggedLemmasForms& forms) const;
\&      virtual string rawLemma(const char* lemma) const;
\&      virtual string lemmaId(const char* lemma) const;
\&      virtual string rawForm(const char* form) const;
\&  
\&      virtual Tokenizer* newTokenizer() const;
\&  
\&      virtual Derivator* getDerivator() const;
\&    };
\&  
\&    class Tagger {
\&     public:
\&      static Tagger* load(const char* fname);
\&  
\&      virtual const Morpho* getMorpho() const;
\&  
\&      virtual void tag(const Forms& forms, TaggedLemmas& tags, int guesser = Morpho::GUESSER_UNSPECIFIED) const;
\&  
\&      virtual void tagAnalyzed(const Forms& forms, const Analyses& analyses, Indices& tags) const;
\&  
\&      Tokenizer* newTokenizer() const;
\&    };
.Ve
.SH "Examples"
.IX Header "Examples"
.SS "run_morpho_cli"
.IX Subsection "run_morpho_cli"
Simple example performing morphological analysis and generation.
.PP
.Vb 3
\&  use warnings;
\&  use strict;
\&  use open qw(:std :utf8);
\&  
\&  use Ufal::MorphoDiTa;
\&  
\&  @ARGV >= 1 or die "Usage: $0 dict_file\en";
\&  
\&  print STDERR "Loading dictionary: ";
\&  my $morpho = Ufal::MorphoDiTa::Morpho::load($ARGV[0]);
\&  $morpho or die "Cannot load dictionary from file \*(Aq$ARGV[0]\*(Aq\en";
\&  print STDERR "done\en";
\&  shift @ARGV;
\&  
\&  my $lemmas = Ufal::MorphoDiTa::TaggedLemmas\->new();
\&  my $lemmas_forms = Ufal::MorphoDiTa::TaggedLemmasForms\->new();
\&  while (<>) {
\&    chomp;
\&    my @tokens = split /\et/, $_, \-1;
\&    if (@tokens == 1) { #Analyze
\&      my $result = $morpho\->analyze($tokens[0], $Ufal::MorphoDiTa::Morpho::GUESSER, $lemmas);
\&      my $guesser = $result == $Ufal::MorphoDiTa::Morpho::GUESSER ? "Guesser " : "";
\&  
\&      for (my ($i, $size) = (0, $lemmas\->size()); $i < $size; $i++) {
\&        my $lemma = $lemmas\->get($i);
\&        printf "%sLemma: %s %s\en", $guesser, $lemma\->{lemma}, $lemma\->{tag};
\&      }
\&    } elsif (@tokens == 2) { #Generate
\&      my $result = $morpho\->generate($tokens[0], $tokens[1], $Ufal::MorphoDiTa::Morpho::GUESSER, $lemmas_forms);
\&      my $guesser = $result == $Ufal::MorphoDiTa::Morpho::GUESSER ? "Guesser " : "";
\&  
\&      for (my $i = 0; $i < $lemmas_forms\->size(); $i++) {
\&        my $lemma_forms = $lemmas_forms\->get($i);
\&        printf "%sLemma: %s\en", $guesser, $lemma_forms\->{lemma};
\&        for (my $i = 0; $i < $lemma_forms\->{forms}\->size(); $i++) {
\&          my $form = $lemma_forms\->{forms}\->get($i);
\&          printf "  %s %s\en", $form\->{form}, $form\->{tag};
\&        }
\&      }
\&    }
\&  }
.Ve
.SS "run_tagger"
.IX Subsection "run_tagger"
Simple example performing tokenization and PoS tagging.
.PP
.Vb 3
\&  use warnings;
\&  use strict;
\&  use open qw(:std :utf8);
\&  
\&  use Ufal::MorphoDiTa;
\&  
\&  sub encode_entities($) {
\&    my ($text) = @_;
\&    $text =~ s/[&<>"]/$& eq "&" ? "&amp;" : $& eq "<" ? "&lt;" : $& eq ">" ? "&gt;" : "&quot;"/ge;
\&    return $text;
\&  }
\&  
\&  @ARGV >= 1 or die "Usage: $0 tagger_file\en";
\&  
\&  print STDERR "Loading tagger: ";
\&  my $tagger = Ufal::MorphoDiTa::Tagger::load($ARGV[0]);
\&  $tagger or die "Cannot load tagger from file \*(Aq$ARGV[0]\*(Aq\en";
\&  print STDERR "done\en";
\&  shift @ARGV;
\&  
\&  my $forms = Ufal::MorphoDiTa::Forms\->new();
\&  my $lemmas = Ufal::MorphoDiTa::TaggedLemmas\->new();
\&  my $tokens = Ufal::MorphoDiTa::TokenRanges\->new();
\&  my $tokenizer = $tagger\->newTokenizer();
\&  $tokenizer or die "No tokenizer is defined for the supplied model!";
\&  
\&  for (my $not_eof = 1; $not_eof; ) {
\&    my $text = \*(Aq\*(Aq;
\&  
\&    # Read block
\&    while (1) {
\&      my $line = <>;
\&      last unless ($not_eof = defined $line);
\&      $text .= $line;
\&      chomp($line);
\&      last unless length $line;
\&    }
\&  
\&    # Tag
\&    $tokenizer\->setText($text);
\&    my $t = 0;
\&    while ($tokenizer\->nextSentence($forms, $tokens)) {
\&      $tagger\->tag($forms, $lemmas);
\&  
\&      for (my ($i, $size) = (0, $lemmas\->size()); $i < $size; $i++) {
\&        my $lemma = $lemmas\->get($i);
\&        my $token = $tokens\->get($i);
\&        my ($token_start, $token_length) = ($token\->{start}, $token\->{length});
\&  
\&        printf "%s%s<token lemma=\e"%s\e" tag=\e"%s\e">%s</token>%s",
\&          encode_entities(substr $text, $t, $token_start \- $t),
\&          $i == 0 ? "<sentence>" : "",
\&          encode_entities($lemma\->{lemma}),
\&          encode_entities($lemma\->{tag}),
\&          encode_entities(substr $text, $token_start, $token_length),
\&          $i + 1 == $size ? "</sentence>" : "";
\&        $t = $token_start + $token_length;
\&      }
\&    }
\&    print encode_entities(substr $text, $t);
\&  }
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Milan Straka <straka@ufal.mff.cuni.cz>
.PP
Jana Strakova\*' <strakova@ufal.mff.cuni.cz>
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
Copyright 2015 Institute of Formal and Applied Linguistics, Faculty of
Mathematics and Physics, Charles University in Prague, Czech Republic.
.PP
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the \s-1MPL\s0 was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.
